#include <chrono>
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"

#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/point.hpp>
#include <geometry_msgs/msg/transform_stamped.hpp>
#include "tf2_ros/static_transform_broadcaster.h"
#include <tf2_ros/transform_listener.h>
#include "tf2_ros/buffer.h"

#include <nav2_msgs/action/navigate_to_pose.hpp>
#include <std_msgs/msg/int32_multi_array.hpp>
#include <std_msgs/msg/int32.hpp>

//#include <zed_interfaces/msg/object.hpp>
//#include <zed_interfaces/msg/objects_stamped.hpp>

#include <zed_msgs/msg/object.hpp>
#include <zed_msgs/msg/objects_stamped.hpp>
#include <sensor_msgs/msg/joy.hpp>


using NavigateToPose = nav2_msgs::action::NavigateToPose;
using GoalHandleNavigateToPose = rclcpp_action::ClientGoalHandle<NavigateToPose>;
using PoseStamped = geometry_msgs::msg::PoseStamped;

class GoalPublisher : public rclcpp::Node {
public:
    GoalPublisher() : Node("zed_goal_publisher") {
        // トピック名のパラメータ宣言
        std::string skeleton_topic = this->declare_parameter<std::string>("skeleton_topic", "zed/zed_node/body_trk/skeletons");
        std::string target_arm_pose_topic = this->declare_parameter<std::string>("target_arm_pose_topic", "target_arm_pose");
        std::string current_arm_pose_topic = this->declare_parameter<std::string>("current_arm_pose_topic", "current_arm_pose");
        std::string cmd_vel_topic = this->declare_parameter<std::string>("cmd_vel_topic", "cmd_vel");
        std::string goal_pose_topic = this->declare_parameter<std::string>("goal_pose_topic", "goal_pose");
        std::string zed_goal_status_topic = this->declare_parameter<std::string>("zed_goal_status_topic", "zed_goal_status");

        // 速度パラメータの宣言（両手上げ：前進）
        forward_vel_fast_ = this->declare_parameter<double>("forward_vel_fast", 0.5);
        forward_vel_slow_ = this->declare_parameter<double>("forward_vel_slow", 0.1);

        // 速度パラメータの宣言（右手曲げ：右旋回）
        turn_right_vel_fast_ = this->declare_parameter<double>("turn_right_vel_fast", 1.6);
        turn_right_vel_slow_ = this->declare_parameter<double>("turn_right_vel_slow", 0.05);

        // 速度パラメータの宣言（左手曲げ：左旋回）
        turn_left_vel_fast_ = this->declare_parameter<double>("turn_left_vel_fast", -1.6);
        turn_left_vel_slow_ = this->declare_parameter<double>("turn_left_vel_slow", -0.05);

        // 速度パラメータの宣言（右手水平：右移動）
        strafe_right_vel_fast_ = this->declare_parameter<double>("strafe_right_vel_fast", 0.70);
        strafe_right_vel_slow_ = this->declare_parameter<double>("strafe_right_vel_slow", 0.10);

        // 速度パラメータの宣言（左手水平：左移動）
        strafe_left_vel_fast_ = this->declare_parameter<double>("strafe_left_vel_fast", -0.70);
        strafe_left_vel_slow_ = this->declare_parameter<double>("strafe_left_vel_slow", -0.10);

        // ZEDで人物認識した内容をsubscribeする
        objectSubscriber_ = this->create_subscription<zed_msgs::msg::ObjectsStamped>(
            skeleton_topic, 1, std::bind(&GoalPublisher::objectCallback, this, std::placeholders::_1));

        arm_pose_Subscriber_ = this->create_subscription<std_msgs::msg::Int32MultiArray>(
            target_arm_pose_topic, 1, std::bind(&GoalPublisher::arm_pose_Callback, this, std::placeholders::_1));

        // joyトピックをsubscribeする（navigationモードとmanualモードの切り替え用）
        joySubscriber_ = this->create_subscription<sensor_msgs::msg::Joy>(
            "joy", 1, std::bind(&GoalPublisher::joyCallback, this, std::placeholders::_1));

        // TF2 Transform Listener
        recognization_frame_ = this->declare_parameter<std::string>("odom", "zed_camera_link");
        tf_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        target_tf_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
        target_tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*target_tf_buffer_);
        timer_ = this->create_wall_timer(std::chrono::seconds(1), std::bind(&GoalPublisher::on_timer, this));

        // Create a publisher for target_arm_position
        arm_pose_Publisher_= this->create_publisher<std_msgs::msg::Int32MultiArray>(target_arm_pose_topic, 10);

        // Create a publisher for target_arm_position
        current_arm_pose_Publisher_= this->create_publisher<std_msgs::msg::Int32MultiArray>(current_arm_pose_topic, 10);

        // Create a publisher for cmd_vel 人物認識からの動作用
        cmdVelPublisher_ = this->create_publisher<geometry_msgs::msg::Twist>(cmd_vel_topic, 1);

        // Create publisher for goal
        goal_publisher_ = this->create_publisher<geometry_msgs::msg::PoseStamped>(goal_pose_topic, 10);

        //
        zed_goal_status_ =this->create_publisher<std_msgs::msg::Int32>(zed_goal_status_topic, 1);

        // Create action client for NavigateToPose action
        action_client_ = rclcpp_action::create_client<NavigateToPose>(this, "navigate_to_pose");

        // メンバ変数の初期化
        arm_message_.data = {0, 0, 0, 0};  // 4要素の配列として初期化
        cmdVelMsg_.linear.x = 0.0;
        cmdVelMsg_.linear.y = 0.0;
        cmdVelMsg_.linear.z = 0.0;
        cmdVelMsg_.angular.x = 0.0;
        cmdVelMsg_.angular.y = 0.0;
        cmdVelMsg_.angular.z = 0.0;

        // navigation mode / manual mode の初期化（デフォルトはmanual mode）
        navigation_activate_ = 0;

    }

private:
    
//------------------------------------------------------------------------------------------
    void set_goal_point(){
        geometry_msgs::msg::TransformStamped tf;
        //tryの中にあるlookupTransformでmapから目標となる人のTF（target_person）を生成するの位置を取得している
        try {
            tf = target_tf_buffer_->lookupTransform(
                "map", "target_person",
                tf2::TimePointZero);
           //robot_pose.translation = t.transform.translation;
            RCLCPP_INFO(this->get_logger(), "------------------- find target_person -----------------");
            RCLCPP_INFO(this->get_logger(), "target_person.x =   : %6.3f"  , tf.transform.translation.x);
            RCLCPP_INFO(this->get_logger(), "target_person.y =   : %6.3f"  , tf.transform.translation.y);
            RCLCPP_INFO(this->get_logger(), "target_person.z =   : %6.3f"  , tf.transform.translation.z);
            RCLCPP_INFO(this->get_logger(), "target_person.r =   : %6.3f"  , tf.transform.rotation.x);
            RCLCPP_INFO(this->get_logger(), "target_person.p =   : %6.3f"  , tf.transform.rotation.y);
            RCLCPP_INFO(this->get_logger(), "target_person.y =   : %6.3f"  , tf.transform.rotation.z);
            RCLCPP_INFO(this->get_logger(), "target_person.w =   : %6.3f"  , tf.transform.rotation.w);
            RCLCPP_INFO(this->get_logger(), "-------------------------------------------------------");

        } catch (const tf2::TransformException & ex) {
            RCLCPP_INFO(
                this->get_logger(), "Could not transform map to target_person: %s" , ex.what());
            return;
        }

        //アクション　Goalの作成
        auto goal_msg = NavigateToPose::Goal();
        goal_msg.pose.header.stamp = this->now();
        goal_msg.pose.header.frame_id = "map";
        //ゴールの座標を定義する
        goal_msg.pose.pose.position.x =tf.transform.translation.x;
        goal_msg.pose.pose.position.y =tf.transform.translation.y;
        goal_msg.pose.pose.position.z =tf.transform.translation.z;
        goal_msg.pose.pose.orientation.x =tf.transform.rotation.x;
        goal_msg.pose.pose.orientation.y =tf.transform.rotation.y;
        goal_msg.pose.pose.orientation.z =tf.transform.rotation.z;
        goal_msg.pose.pose.orientation.w =tf.transform.rotation.w;

        //進捗状況を表示するFeedbackコールバックを設定
        auto send_goal_options = rclcpp_action::Client<NavigateToPose>::SendGoalOptions();
        send_goal_options.feedback_callback = std::bind(&GoalPublisher::feedbackCallback, this, std::placeholders::_1, std::placeholders::_2);
        send_goal_options.result_callback   = std::bind(&GoalPublisher::resultCallback, this, std::placeholders::_1);
        
        //Goal をサーバーに送信        
        action_client_->async_send_goal(goal_msg, send_goal_options);

        PoseStamped goal_pose_msg;
        // Fill in the PoseStamped message fields
        goal_pose_msg.header.stamp = this->now();
        goal_pose_msg.header.frame_id = "map"; // Adjust the frame_id according to your application
        goal_pose_msg.pose.position.x =tf.transform.translation.x;
        goal_pose_msg.pose.position.y =tf.transform.translation.y;
        goal_pose_msg.pose.position.z =tf.transform.translation.z;
        goal_pose_msg.pose.orientation.x =tf.transform.rotation.x;
        goal_pose_msg.pose.orientation.y =tf.transform.rotation.y;
        goal_pose_msg.pose.orientation.z =tf.transform.rotation.z;
        goal_pose_msg.pose.orientation.w =tf.transform.rotation.w;
        goal_publisher_ ->publish(goal_pose_msg);

        //ゴール地点を表示
        RCLCPP_INFO(this->get_logger(),"---------- goal_point published --------------");
        RCLCPP_INFO(this->get_logger(),"goal_x       : %4.3f", goal_msg.pose.pose.position.x); 
        RCLCPP_INFO(this->get_logger(),"goal_y       : %4.3f", goal_msg.pose.pose.position.y);
        RCLCPP_INFO(this->get_logger(),"goal_z       : %4.3f", goal_msg.pose.pose.position.z );                
        RCLCPP_INFO(this->get_logger(),"goal_x       : %4.3f", goal_msg.pose.pose.position.x); 
        RCLCPP_INFO(this->get_logger(),"goal_rx      : %4.3f", goal_msg.pose.pose.orientation.x);
        RCLCPP_INFO(this->get_logger(),"goal_ry      : %4.3f", goal_msg.pose.pose.orientation.y);
        RCLCPP_INFO(this->get_logger(),"goal_rz      : %4.3f", goal_msg.pose.pose.orientation.z);
        RCLCPP_INFO(this->get_logger(),"goal_rw      : %4.3f", goal_msg.pose.pose.orientation.w);
        RCLCPP_INFO(this->get_logger(),"----------------------------------------------");

        //arm.header.stamp = ros::Time::now();
        //arm.position[0]= theta;
        //arm.position[1]= -0.5;
        //arm.position[2]=  1.0;    
        //joint_pub.publish(arm);
        //ros::Duration(1.0).sleep();
    }    

//---------------------- ZED2iで人物認識した内容の処理を行う ---------------------------------------------------
    void objectCallback(const zed_msgs::msg::ObjectsStamped::SharedPtr objMsg)
    {
        using namespace std::chrono_literals;

        // ★ navigation_activate_が0（manual mode）の場合は処理を停止
        if (navigation_activate_ == 0) {
            // manual modeでは人物認識による自動制御を行わない
            return;
        }

        // Skeleton joints indices
        //        16-14   15-17
        //             \ /
        //              0
        //              |
        //       2------1------5
        //       |    |   |    |
        //	     |    |   |    |
        //       3    |   |    6
        //       |    |   |    |
        //       |    |   |    |
        //       4    8   11   7
        //            |   |
        //            |   |
        //            |   |
        //            9   12
        //            |   |
        //            |   |
        //            |   |
        //           10   13
        if (objMsg->objects.size()>0){
            //target_pointを初期化する
            //target_point.x =0.001;
            //target_point.y =0.0001;
            //target_point.z =0.0001;
            //RCLCPP_INFO(this->get_logger(), "I find %ld person", objMsg->objects.size());
            if(zed_goal_msg.data<1){//すでに目標を発見もしくはゴールしていたなら人物認識していることを除外
                zed_goal_msg.data=1;//人物認識通知
            }
            
            //一応アームは初期位置にしておく
            arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                            ,200
                                            ,200
                                            ,-200
                                            };
            arm_pose_Publisher_->publish(arm_message_);
                
            //人物が複数人見つかった場合、より遠くにいる人を目標地点とする
            for(uint i = 0 ; i < objMsg->objects.size()  ; i++ ){
                if(objMsg->objects[i].tracking_state>0){
                    for(int pose_count = 2 ; pose_count <= 7 ; pose_count++ ){//首下のx方向の位置を取得する
                        //if (isnan(objMsg->objects[i].skeleton_3d.keypoints[3].kp[2])) {
                        if (std::isnan(objMsg->objects[i].skeleton_3d.keypoints[3].kp[1])) {
                            body_pose_x[pose_count] =0;
                        }
                        else{
                            body_pose_x[pose_count] = objMsg->objects[i].skeleton_3d.keypoints[pose_count].kp[1];
                        }
                    }

                    for(int pose_count = 2 ; pose_count <= 7 ; pose_count++ ){//首下のY方向の位置を取得する
                        //if (isnan(objMsg->objects[i].skeleton_3d.keypoints[3].kp[2])) {
                        if (std::isnan(objMsg->objects[i].skeleton_3d.keypoints[3].kp[2])) {
                            body_pose_y[pose_count] =0;
                        }
                        else{
                            body_pose_y[pose_count] = objMsg->objects[i].skeleton_3d.keypoints[pose_count].kp[2];
                        }    
                    }

                    target_point.x =objMsg->objects[i].position[0];
                    target_point.y =objMsg->objects[i].position[1];
                    target_point.z =objMsg->objects[i].position[2];    
                    //RCLCPP_INFO(this->get_logger(), "body_pose_y[2] =   : %6.3f", body_pose_y[2]);
                    //RCLCPP_INFO(this->get_logger(), "body_pose_y[4] =   : %6.3f", body_pose_y[4]);
                    //RCLCPP_INFO(this->get_logger(), "body_pose_y[5] =   : %6.3f", body_pose_y[5]);
                    //RCLCPP_INFO(this->get_logger(), "body_pose_y[7] =   : %6.3f", body_pose_y[7]);
                                        
                    //肩から上に手を上げた人を見つける
                    if(body_pose_y[2] < (body_pose_y[4]-0.3) || body_pose_y[5] < (body_pose_y[7]-0.3)){
                        //RCLCPP_INFO(this->get_logger(), "I find you");
                        person_finding = true;//
                        compare_point.x =objMsg->objects[i].position[0];
                        compare_point.y =objMsg->objects[i].position[1];
                        compare_point.z =objMsg->objects[i].position[2];
                        //target_point.x =objMsg->objects[i].position[0];
                        //target_point.y =objMsg->objects[i].position[1];
                        //target_point.z =objMsg->objects[i].position[2];
                        if(compare_point.x > target_point.x){//より遠くの人をターゲットにする
                            target_point.x =objMsg->objects[i].position[0];
                            target_point.y =objMsg->objects[i].position[1];
                            target_point.z =objMsg->objects[i].position[2];
                        }
                        RCLCPP_INFO(this->get_logger(),"---------- get target point --------------");
                        RCLCPP_INFO(this->get_logger(), "target_point.x =   : %6.3f", target_point.x);
                        RCLCPP_INFO(this->get_logger(), "target_point.y =   : %6.3f", target_point.y);
                        RCLCPP_INFO(this->get_logger(), "target_point.z =   : %6.3f", target_point.z);
                        RCLCPP_INFO(this->get_logger(),"------------------------------------------");
                        zed_goal_msg.data=2;//目標発見通知
                        //ターゲットとなった人の角度に合わせてアームの向きを合わせる
                        arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                            ,arm_message_.data[1]
                                            ,arm_message_.data[2]
                                            ,arm_message_.data[3]
                                            };
                        arm_pose_Publisher_->publish(arm_message_);
                        //アームのグリッパーをパクパクさせる
                        rclcpp::sleep_for(600ms);
                        arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                            ,arm_message_.data[1]
                                            ,arm_message_.data[2]
                                            ,20
                                            };
                        arm_pose_Publisher_->publish(arm_message_);
                        rclcpp::sleep_for(600ms);
                        arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                            ,arm_message_.data[1]
                                            ,arm_message_.data[2]
                                            ,-160
                                            };
                        arm_pose_Publisher_->publish(arm_message_);
                        rclcpp::sleep_for(600ms);
                        arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                            ,arm_message_.data[1]
                                            ,arm_message_.data[2]
                                            ,0
                                            };
                        arm_pose_Publisher_->publish(arm_message_);
                        arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                            ,arm_message_.data[1]
                                            ,arm_message_.data[2]
                                            ,-160
                                            };
                        arm_pose_Publisher_->publish(arm_message_);

                        current_arm_pose_Publisher_->publish(arm_message_);//最後に現状の角度を出力させる
                        rclcpp::sleep_for(1500ms);
                        //RCLCPP_INFO(this->get_logger(), "taget_point.x= %5.8f",target_point.x);
                        break;   
                    }
                
                    else{
                        person_finding = false;
                    }//end else
                }//end if(objMsg->objects[i].tracking_state>0)
            }//end for
            if(target_point.x > 1.0){
                //目標となる人のTF（target_person）を生成する
                static_tf_broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(this);
                geometry_msgs::msg::TransformStamped transformStamped;
                transformStamped.header.stamp = this->now();
                transformStamped.header.frame_id = "zed_camera_link"; // 親フレーム
                transformStamped.child_frame_id  = "target_person"; // 子フレーム
                transformStamped.transform.translation = target_point;
                double offset =0.6;
                transformStamped.transform.translation.x = target_point.x - offset;
                tf2::Quaternion quaternion;
                quaternion.setRPY(0, 0, (atan(target_point.y/target_point.x)/M_PI));
                transformStamped.transform.rotation.x = quaternion.x();
                transformStamped.transform.rotation.y = quaternion.y();
                transformStamped.transform.rotation.z = quaternion.z();
                transformStamped.transform.rotation.w = quaternion.w();
                
                // tfメッセージをbroadcast
                static_tf_broadcaster_->sendTransform(transformStamped);
                //以下のset_goal_pointで目標位置を生成する
                //set_goal_point();
            }
            else if(target_point.x <0.8 ){//もし近くに人がいるならばアームを前に出す

                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,200
                                    ,80
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                //アームのグリッパーをパクパクさせる
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,100
                                    ,-20
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,50
                                    ,-70
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,0
                                    ,-120
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,-50
                                    ,-190
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,-150
                                    ,-190
                                    ,50
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(2000ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,-150
                                    ,-190
                                    ,-100
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,50
                                    ,-100
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,100
                                    ,80
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                rclcpp::sleep_for(600ms);
                arm_message_.data = { int32_t(atan(target_point.y/target_point.x)*80)
                                    ,200
                                    ,200
                                    ,-200
                                    };
                arm_pose_Publisher_->publish(arm_message_);
                //アームのグリッパーをパクパクさせる
                rclcpp::sleep_for(600ms);

            }
        }//end if (objMsg->objects.size()>0)
        else{
        //callbackしている時点で何らか認識しているため、ここでは特に何もしない。  
        }
        //目標地点を初期化する
        target_point.x =0.001;
        target_point.y =0.0001;
        target_point.z =0.0001;
    } //end objectCallback

//------------------- joyコールバック（navigationモードとmanualモードの切り替え） -----------------------------------------------
void joyCallback(const sensor_msgs::msg::Joy::SharedPtr joyMsg)
{
    // ボタン9（OPTIONS）: navigation mode
    if(joyMsg->buttons[9] == 1){
        RCLCPP_INFO(this->get_logger(), "********************************");
        RCLCPP_INFO(this->get_logger(), "     NAVIGATION MODE            ");
        RCLCPP_INFO(this->get_logger(), "********************************");
        navigation_activate_ = 1;
    }
    // ボタン12（PS）: manual mode
    else if(joyMsg->buttons[12] == 1){
        RCLCPP_INFO(this->get_logger(), "********************************");
        RCLCPP_INFO(this->get_logger(), "     MANUAL MODE                ");
        RCLCPP_INFO(this->get_logger(), "********************************");
        navigation_activate_ = 0;
    }
}

//-------------------現状のアーム角度を取得する -----------------------------------------------
void arm_pose_Callback(const std_msgs::msg::Int32MultiArray::SharedPtr msgin)
    {
        arm_message_.data ={  msgin->data[0]
                            ,msgin->data[1]
                            ,msgin->data[2]
                            ,msgin->data[3]
                            };
        //arm_pose_Publisher_->publish(arm_message_);
    }
//------------------1秒ごとにodomとZED2カメラの位置を取得する--------------------------------------
    void on_timer()
    {
        geometry_msgs::msg::TransformStamped t;
        //tryの中にあるlookupTransformでカメラの位置を取得している
        try {
            t = tf_buffer_->lookupTransform(
                "odom", "zed_camera_link",
                tf2::TimePointZero);
           //robot_pose.translation = t.transform.translation;
            robot_pose.transform      = t.transform;  
            robot_pose_yaw  = t.transform.rotation.z; 
            /*
            RCLCPP_INFO(this->get_logger(), "robot_pose.x =   : %6.3f", robot_pose.transform.translation.x);
            RCLCPP_INFO(this->get_logger(), "robot_pose.y =   : %6.3f", robot_pose.transform.translation.y);
            RCLCPP_INFO(this->get_logger(), "robot_pose.z =   : %6.3f", robot_pose.transform.translation.z);
            RCLCPP_INFO(this->get_logger(), "robot_rotate.z =   : %6.3f", robot_pose.transform.rotation.z);
            RCLCPP_INFO(this->get_logger(), "robot_rotate.w =   : %6.3f", robot_pose.transform.rotation.w);
            RCLCPP_INFO(this->get_logger(), "---------------------------------------------------");
            */

        } catch (const tf2::TransformException & ex) {
            RCLCPP_INFO(
                this->get_logger(), "Could not transform odom to zed_camera_link: %s" , ex.what());
            return;
        }
        if(pre_zed_goal_msg.data!=zed_goal_msg.data){
            zed_goal_status_->publish(zed_goal_msg);//ゴール認識状態を通知
            pre_zed_goal_msg.data=zed_goal_msg.data;
        }
    }

    //------------action_client_のfeedbackを生成-----------------------------------------------------------
    void feedbackCallback(GoalHandleNavigateToPose::SharedPtr,const std::shared_ptr<const NavigateToPose::Feedback> feedback)
    {
        RCLCPP_INFO(get_logger(), "Distance remaininf = %f", feedback->distance_remaining);
    }
    //------------action_client_のresultを生成-----------------------------------------------------------
    void resultCallback(const GoalHandleNavigateToPose::WrappedResult & result)
    {
        switch (result.code) {
            case rclcpp_action::ResultCode::SUCCEEDED:
                RCLCPP_INFO(get_logger(), "Success!!!");
                zed_goal_msg.data=3;//ゴールしたことを通知
                zed_goal_status_->publish(zed_goal_msg);
                break;
            case rclcpp_action::ResultCode::ABORTED:
                RCLCPP_ERROR(get_logger(), "Goal was aborted");
                zed_goal_msg.data=4;//ゴールしたことを通知
                zed_goal_status_->publish(zed_goal_msg);
                return;
            case rclcpp_action::ResultCode::CANCELED:
                RCLCPP_ERROR(get_logger(), "Goal was canceled");
                zed_goal_msg.data=5;//ゴールしたことを通知
                zed_goal_status_->publish(zed_goal_msg);
                return;
            default:
                RCLCPP_ERROR(get_logger(), "Unknown result code");
                return;
        }
    }

    rclcpp_action::Client<NavigateToPose>::SharedPtr action_client_;
    rclcpp::Subscription<zed_msgs::msg::ObjectsStamped>::SharedPtr objectSubscriber_;
    rclcpp::Subscription<std_msgs::msg::Int32MultiArray>::SharedPtr  arm_pose_Subscriber_;
    rclcpp::Subscription<sensor_msgs::msg::Joy>::SharedPtr joySubscriber_;
    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr      cmdVelPublisher_;

    std::shared_ptr<tf2_ros::Buffer> tf_buffer_;
    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
    std::shared_ptr<tf2_ros::Buffer> target_tf_buffer_;
    std::shared_ptr<tf2_ros::TransformListener> target_tf_listener_;
    std::shared_ptr<tf2_ros::StaticTransformBroadcaster> static_tf_broadcaster_;

    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr goal_publisher_;
    rclcpp::Publisher<std_msgs::msg::Int32MultiArray>::SharedPtr  arm_pose_Publisher_;
    rclcpp::Publisher<std_msgs::msg::Int32MultiArray>::SharedPtr  current_arm_pose_Publisher_;
    rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr zed_goal_status_;
    rclcpp::TimerBase::SharedPtr timer_{nullptr};
    std::string recognization_frame_;
    bool person_finding;                        //人物認識できた際のフラグ
    geometry_msgs::msg::Vector3 compare_point;  //手を上げた人の位置取得用(それぞれの人の位置)
    geometry_msgs::msg::Vector3 target_point;   //手を上げた人の位置取得用(比較して選定した人の最終目標位置)
    float body_pose_x[20];
    float body_pose_y[20];
    std_msgs::msg::Int32 zed_goal_msg;
    std_msgs::msg::Int32 pre_zed_goal_msg;
    geometry_msgs::msg::TransformStamped robot_pose;  //odom→zed_camera_link間となるロボット位置取得用
    double robot_pose_yaw=0.0001;              //zed2による物体認識から目標位置の角度取得用
    double leave_distance=0.60;                //1歩下がった位置にゴールを指定するため、1歩の距離を指定する

    // グローバル変数から移動したメンバ変数
    std_msgs::msg::Int32MultiArray arm_message_;
    geometry_msgs::msg::Twist cmdVelMsg_;

    // navigation mode / manual mode フラグ
    int navigation_activate_;

    // 速度パラメータ
    double forward_vel_fast_;       // 両手上げ：前進（高速）
    double forward_vel_slow_;       // 両手上げ：前進（低速）
    double turn_right_vel_fast_;    // 右手曲げ：右旋回（高速）
    double turn_right_vel_slow_;    // 右手曲げ：右旋回（低速）
    double turn_left_vel_fast_;     // 左手曲げ：左旋回（高速）
    double turn_left_vel_slow_;     // 左手曲げ：左旋回（低速）
    double strafe_right_vel_fast_;  // 右手水平：右移動（高速）
    double strafe_right_vel_slow_;  // 右手水平：右移動（低速）
    double strafe_left_vel_fast_;   // 左手水平：左移動（高速）
    double strafe_left_vel_slow_;   // 左手水平：左移動（低速）

};

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<GoalPublisher>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}